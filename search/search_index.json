{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About the project","text":"<p><code>treefmt</code> is a formatting tool that saves you time: it provides developers with a universal way to trigger all formatters needed for the project in one place.</p>"},{"location":"#background","title":"Background","text":"<p>Typically, each project has its own code standards enforced by the project's owner. Any code contributions must match that given standard, i.e. be formatted in a specific manner.</p> <p>At first glance, the task of code formatting may seem trivial: the formatter can be automatically triggered when you save a file in your IDE. Indeed, formatting doesn't take much effort if you're working on a single project long term: setting up the formatters in your IDE won't take much of your time, and then you're ready to go.</p> <p>Contrary to that, if you're working on multiple projects at the same time, you may have to update your formatter configs in the IDE each time you switch between the projects. This is because formatter settings aren't project-specific --- they are set up globally for all projects.</p> <p>Alternatively, you can trigger formatters manually, one-by-one or in a script. Actually, for bigger projects, it's common to have a script that runs over your project's directories and calls formatters consequently. But it takes time to iterate through all the files.</p> <p>All the solutions take up a significant amount of time which a developer could spend doing the actual work. They also require you to remember which formatters and options are used by each project you are working on.</p> <p><code>treefmt</code> solves these issues.</p>"},{"location":"#why-treefmt","title":"Why treefmt?","text":"<p><code>treefmt</code>'s configuration is project-specific, so you don't need to re-configure formatters each time you switch between projects, like you have to when working with formatters in the IDE.</p> <p>Contrary to calling formatters from the command line, there's no need to remember all the specific formatters required for each project. Once you set up the config, you can run the tool in any of your project's folders without any additional flags or options.</p> <p>Typically, formatters have different ways to say there was a specific error. With <code>treefmt</code>, you get a standardized output which is easier to understand than the variegated outputs of different formatters, so it takes less time to grasp what's wrong.</p> <p>In addition, <code>treefmt</code> works faster than the custom script solution because the changed files are cached and the formatters run only against them. Moreover, formatters are run in parallel, which makes the tool even faster.</p> <p>The difference may not be significant for smaller projects, but it gets quite visible as the project grows. For instance, take the caching optimization. It takes 9 seconds to traverse a project of 1507 files and no changes without caching:</p> <pre><code>traversed 1507 files\nmatched 828 files to formatters\nleft with 828 files after cache\nof whom 0 files were re-formatted\nall of this in 9s\n</code></pre> <p>...while it takes 124 milliseconds to traverse the same project with caching:</p> <pre><code>traversed 1507 files\nmatched 828 files to formatters\nleft with 0 files after cache\nof whom 0 files were re-formatted\nall of this in 124ms\n</code></pre> <p>The tool can be invoked manually or integrated into your CI. There's currently no integration with IDEs, but the feature is coming soon.</p>"},{"location":"#what-we-still-need-help-with","title":"What we still need help with","text":"<ul> <li>IDE integration: Most of developers are used to formatting a file upon save in the IDE. So far, you can't use <code>treefmt</code> for this purpose, but we're working on it \ud83d\ude00</li> <li>Pre-commit hook: It's good to have your code checked for adherence to the project's standards before commit. <code>treefmt</code> pre-commit hook won't let you commit if you have formatting issues.</li> <li>Support of multiple formatters for one language: In the current version, we advise you to avoid using multiple formatters for one and the same file type. This is because formatters are run in parallel and therefore may encounter issues while processing files. We are going to fix this issue soon, since there are cases when you may need more than one formatter per language.</li> </ul> <p>As a next step, learn how to install and use <code>treefmt</code>.</p>"},{"location":"contributing/","title":"Contribution guidelines","text":"<p>This file contains instructions that will help you make a contribution.</p>"},{"location":"contributing/#licensing","title":"Licensing","text":"<p>The treefmt binaries and this user guide are licensed under the MIT license.</p>"},{"location":"contributing/#before-you-contribute","title":"Before you contribute","text":"<p>Here you can take a look at the existing issues. Feel free to contribute, but make sure you have a GitHub account first :) .</p> <p>If you're new to open source, please read GitHub's guide on How to Contribute to Open Source. It's a quick read, and it's a great way to introduce yourself to how things work behind the scenes in open-source projects.</p> <p>Before sending a pull request, make sure that you've read all the guidelines. If you don't understand something, please state your question clearly in an issue or ask the community on the treefmt matrix server.</p>"},{"location":"contributing/#creating-an-issue","title":"Creating an issue","text":"<p>If you need to create an issue, make sure to clearly describe it, including:</p> <ul> <li>The steps to reproduce it if it's a bug</li> <li>The version of treefmt used</li> <li>The database driver and version</li> <li>The database version</li> </ul> <p>The cache database is stored in a toml file the ~/.cache/treefmt directory.</p>"},{"location":"contributing/#making-changes","title":"Making changes","text":"<p>If you want to introduce changes to the project, please follow these steps:</p> <ul> <li>Fork the repository on GitHub</li> <li>Create a branch on your fork. Don't commit directly to main</li> <li>Add the necessary tests for your changes</li> <li>Run treefmt in the source directory before you commit your changes</li> <li>Push your changes to the branch in your repository fork</li> <li>Submit a pull request to the original repository</li> </ul> <p>Make sure you based your commits on logical and atomic units!</p>"},{"location":"contributing/#examples-of-git-history","title":"Examples of git history","text":"<p>Git history that we want to have:</p> <p>Git history that we are trying to avoid:</p> Git history that we want to have <pre><code>*   e3ed88b (HEAD -&gt; contribution-guide, upstream/main, origin/main, origin/HEAD, main) Merge pull request #470 from zimbatm/fix_lru_cache\n\n|\\\n\n| * 1ab7d9f Use rayon for multithreading command\n\n|/\n\n*   e9c5bb4 Merge pull request #468 from zimbatm/multithread\n\n|\\\n\n| * de2d6cf Add lint property for Formatter struct\n\n| * cd2ed17 Fix impl on Formatter get_command() function\n\n|/\n\n*   028c344 Merge pull request #465 from rayon/0.15.0-release\n\n|\\\n\n| * 7b619d6 0.15.0 release\n\n|/\n\n*   acdf7df Merge pull request #463 from zimbatm/support-multi-part-namespaces\n</code></pre> Git history that we are trying to avoid: <pre><code>*   4c8aca8 Merge pull request #120 from zimbatm/add-rayon\n\n|\\\n\n| * fc2b449 use rayon for engine now\n\n| * 2304683 add rayon config\n\n| * 5285bd3 bump base image to F30\n\n* |   4d0fbe2 Merge pull request #114 from rizary/create_method_create_release\n\n|\\ \\\n\n| * | 36a9396 test changed\n\n| * | 22f681d method create release for github created\n\n* | |   2ef4ea1 Merge pull request #119 from rizary/config.rs\n\n|\\ \\ \\\n\n| |/ /\n\n|/| |\n\n| * | 5f1b8f0 unused functions removed\n\n* | |   a93c361 Merge pull request #117 from zimbatm/add-getreleases-to-abstract\n\n|\\ \\ \\\n\n| |/ /\n\n|/| |\n\n| * | 0a97236 add get_releses for Cargo\n\n| * | 55e4c57 add get_releases/get_release into engine.rs\n\n|/ /\n\n* |   badeddd Merge pull request #101 from zimbatm/extreme-cachin\n</code></pre> <p>Additionally, it's always good to work on improving documentation and adding examples.</p> <p>Thank you for considering contributing to <code>treefmt</code>.</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#how-does-treefmt-function","title":"How does treefmt function?","text":"<p><code>Treefmt</code> traverses all your project's folders, maps files to specific code formatters, and formats the code accordingly. Other tools also traverse the filesystem, but not necessarily starting from the root of the project.</p> <p>Contrary to other formatters, <code>treefmt</code> doesn't preview the changes before writing them to a file. If you want to view the changes, you can always check the diff in your version control (we assume that your project is checked into a version control system). You can also rely on version control if errors were introduced into your code as a result of disruptions in the formatter's work.</p>"},{"location":"faq/#how-is-the-cache-organized","title":"How is the cache organized?","text":"<p>At this moment, the cache is represented by a flat TOML file where file paths are mapped to <code>mtimes</code>. The file is located in:</p> <pre><code>~/.cache/treefmt/&lt;hash-of-the-treefmt.toml-path&gt;.toml\n</code></pre> <p>However, we are planning to move the hash file to the destination project's root directory.</p> <p>At the end of each tool run, the cache file gets overwritten with the last formatting time entries. In this way, we can can compare the last change time of the file to the last formatting time, and figure out which files need re-formatting.</p>"},{"location":"formatters-spec/","title":"Formatter specification","text":"<p>In order to keep the design of <code>treefmt</code> simple, we support only formatters which adhere to a certain standard. This document outlines this standard. If the formatter you would like to use doesn't comply with the rules, it's often possible to create a wrapper script that transforms the usage to match the specification.</p> <p>In this design, we rely on <code>treefmt</code> to do the tree traversal, and only invoke the code formatter on the selected files.</p>"},{"location":"formatters-spec/#rules","title":"Rules","text":"<p>In order for the formatter to comply to this spec, it MUST follow the following rules:</p>"},{"location":"formatters-spec/#1-files-passed-as-arguments","title":"1. Files passed as arguments","text":"<p>In order to be integrated to <code>treefmt</code>'s workflow, the formatter's CLI must adhere to the following specification:</p> <pre><code>&lt;command&gt; [options] [...&lt;files&gt;]\n</code></pre> <p>Where:</p> <ul> <li><code>&lt;command&gt;</code> is the name of the formatting tool.</li> <li><code>[options]</code> is any number of flags and options that the formatter accepts.</li> <li><code>[...&lt;files&gt;]</code> is one or more files given to the formatter for processing.</li> </ul> <p>Example:</p> <pre><code>$ rustfmt --edition 2018 src/main.rs src/lib.rs\n</code></pre> <p>It SHOULD processes only the specified files. Files that are not passed SHOULD never be formatted.</p>"},{"location":"formatters-spec/#2-write-to-changed-files","title":"2. Write to changed files","text":"<p>Whenever there is a change to the code formatting, the code formatter MUST write to the changes back to the original location.</p> <p>If there is no changes to the original file, the formatter MUST NOT write to the original location.</p>"},{"location":"formatters-spec/#3-idempotent","title":"3. Idempotent","text":"<p>The code formatter SHOULD be indempotent. Meaning that it produces stable outputs.</p>"},{"location":"formatters-spec/#4-reliable","title":"4. Reliable","text":"<p>We expect the formatter to be reliable and not break the semantic of the formatted files.</p>"},{"location":"formatters/","title":"Known formatters","text":"<p>Here is a list of all the formatters we tested. Feel free to send a PR to add other ones!</p>"},{"location":"formatters/#contents","title":"Contents","text":"<p>Single-language formatters:</p> <ul> <li>Cabal</li> <li>cabal-fmt</li> <li>Elm</li> <li>elm-format</li> <li>Golang</li> <li>gofmt</li> <li>gofumpt</li> <li>Haskell</li> <li>hlint</li> <li>ormolu</li> <li>stylish-haskell</li> <li>Lua</li> <li>StyLua</li> <li>Nix</li> <li>alejandra</li> <li>nixpkgs-fmt</li> <li>OCaml</li> <li>ocamlformat</li> <li>PureScript</li> <li>purs-tidy</li> <li>Python</li> <li>black</li> <li>Ruby</li> <li>rufo</li> <li>Rust</li> <li>rustfmt</li> <li>Scala</li> <li>scalafmt</li> <li>Shell</li> <li>shellcheck</li> <li>shfmt</li> <li>Terraform</li> <li>terraform fmt</li> <li>Typst</li> <li>typstfmt</li> </ul> <p>Multilanguage formatters:</p> <ul> <li>clang-format</li> <li>Prettier</li> </ul>"},{"location":"formatters/#cabal","title":"Cabal","text":""},{"location":"formatters/#cabal-fmt","title":"cabal-fmt","text":"<pre><code>command = \"cabal-fmt\"\noptions = [\"--inplace\"]\nincludes = [\"*.cabal\"]\n</code></pre>"},{"location":"formatters/#elm","title":"Elm","text":""},{"location":"formatters/#elm-format","title":"elm-format","text":"<pre><code>command = \"elm-format\"\noptions = [\"--yes\"]\nincludes = [\"*.elm\"]\n</code></pre>"},{"location":"formatters/#golang","title":"Golang","text":""},{"location":"formatters/#gofmt","title":"gofmt","text":"<pre><code>command = \"gofmt\"\noptions = [\"-w\"]\nincludes = [\"*.go\"]\n</code></pre>"},{"location":"formatters/#gofumpt","title":"gofumpt","text":"<pre><code>command = \"gofumpt\"\nincludes = [\"*.go\"]\n</code></pre>"},{"location":"formatters/#haskell","title":"Haskell","text":""},{"location":"formatters/#hlint","title":"hlint","text":"<pre><code>command = \"hlint\"\nincludes = [ \"*.hs\" ]\n</code></pre>"},{"location":"formatters/#ormolu","title":"Ormolu","text":"<p>Make sure to use ormolu 0.1.4.0+ as older versions don't adhere to the spec.</p> <pre><code>command = \"ormolu\"\noptions = [\n \"--ghc-opt\", \"-XBangPatterns\",\n \"--ghc-opt\", \"-XPatternSynonyms\",\n \"--ghc-opt\", \"-XTypeApplications\",\n \"--mode\", \"inplace\",\n \"--check-idempotence\",\n]\nincludes = [\"*.hs\"]\n</code></pre>"},{"location":"formatters/#stylish-haskell","title":"stylish-haskell","text":"<pre><code>command = \"stylish-haskell\"\noptions = [ \"--inplace\" ]\nincludes = [ \"*.hs\" ]\n</code></pre>"},{"location":"formatters/#lua","title":"Lua","text":""},{"location":"formatters/#stylua","title":"StyLua","text":"<pre><code>command = \"stylua\"\nincludes = [\"*.lua\"]\n</code></pre>"},{"location":"formatters/#nix","title":"Nix","text":""},{"location":"formatters/#alejandra","title":"Alejandra","text":"<pre><code>command = \"alejandra\"\nincludes = [\"*.nix\"]\n</code></pre>"},{"location":"formatters/#nixpkgs-fmt","title":"nixpkgs-fmt","text":"<pre><code>command = \"nixpkgs-fmt\"\nincludes = [\"*.nix\"]\n</code></pre>"},{"location":"formatters/#ocaml","title":"OCaml","text":""},{"location":"formatters/#ocamlformat","title":"ocamlformat","text":"<pre><code>command = \"ocamlformat\"\noptions = [\"-i\"]\nincludes = [\"*.ml\", \"*.mli\"]\n</code></pre>"},{"location":"formatters/#purescript","title":"PureScript","text":""},{"location":"formatters/#purs-tidy","title":"purs-tidy","text":"<pre><code>command = \"purs-tidy\"\nincludes = [\"*.purs\"]\n</code></pre>"},{"location":"formatters/#python","title":"Python","text":""},{"location":"formatters/#black","title":"black","text":"<pre><code>command = \"black\"\nincludes = [\"*.py\"]\n</code></pre>"},{"location":"formatters/#ruby","title":"Ruby","text":""},{"location":"formatters/#rufo","title":"rufo","text":"<p>Rufo is an opinionated ruby formatter. By default it exits with status 3 on file change so you have to pass the <code>-x</code> option.</p> <pre><code>command = \"rufo\"\noptions = [\"-x\"]\nincludes = [\"*.rb\"]\n</code></pre>"},{"location":"formatters/#rust","title":"Rust","text":"<p>cargo fmt is not supported as it doesn't follow the spec. It doesn't allow to pass arbitrary files to be formatter, an ability which <code>treefmt</code> relies on. Use rustfmt instead (which is what cargo fmt uses under the hood).</p>"},{"location":"formatters/#rustfmt","title":"rustfmt","text":"<pre><code>command = \"rustfmt\"\noptions = [\"--edition\", \"2018\"]\nincludes = [\"*.rs\"]\n</code></pre>"},{"location":"formatters/#scala","title":"Scala","text":""},{"location":"formatters/#scalafmt","title":"scalafmt","text":"<pre><code>command = \"scalafmt\"\nincludes = [\"*.scala\"]\n</code></pre>"},{"location":"formatters/#shell","title":"Shell","text":""},{"location":"formatters/#shellcheck","title":"shellcheck","text":"<pre><code>command = \"shellcheck\"\nincludes = [\"*.sh\"]\n</code></pre>"},{"location":"formatters/#shfmt","title":"shfmt","text":"<pre><code>command = \"shfmt\"\noptions = [\n \"-i\",\n \"2\",  # indent 2\n \"-s\",  # simplify the code\n \"-w\",  # write back to the file\n]\nincludes = [\"*.sh\"]\n</code></pre>"},{"location":"formatters/#terraform","title":"Terraform","text":""},{"location":"formatters/#terraform_1","title":"terraform","text":"<p>Make sure to use terraform 1.3.0 or later versions, as earlier versions format only one file at a time. See the details here.</p> <pre><code>command = \"terraform\"\noptions = [\"fmt\"]\nincludes = [\"*.tf\"]\n</code></pre>"},{"location":"formatters/#typst","title":"Typst","text":""},{"location":"formatters/#typstfmt","title":"typstfmt","text":"<pre><code>command = \"typstfmt\"\nincludes = [\"*.typ\", \"*.typst\"]\n</code></pre>"},{"location":"formatters/#multi-language-formatters","title":"Multi-language formatters","text":""},{"location":"formatters/#clang-format","title":"clang-format","text":"<p>A tool to format C/C++/Java/JavaScript/Objective-C/Protobuf/C# code.</p> <pre><code>command = \"clang-format\"\noptions = [ \"-i\" ]\nincludes = [ \"*.c\", \"*.cpp\", \"*.cc\", \"*.h\", \"*.hpp\" ]\n</code></pre> <p>Note: This example focuses on C/C++ but can be modified to be used with other languages.</p>"},{"location":"formatters/#prettier","title":"Prettier","text":"<p>An opinionated code formatter that supports many languages.</p> <pre><code>command = \"prettier\"\noptions = [\"--write\"]\nincludes = [\n \"*.css\",\n \"*.html\",\n \"*.js\",\n \"*.json\",\n \"*.jsx\",\n \"*.md\",\n \"*.mdx\",\n \"*.scss\",\n \"*.ts\",\n \"*.yaml\",\n]\n</code></pre>"},{"location":"index-formatters/","title":"Formatters","text":"<p>In order to catch up with all the formatters available for different programming languages, we created two files as our guideline:</p> <ol> <li>Formatter Specifications \u2014 Guidelines for formatter creators to have a smooth integration with <code>treefmt</code></li> <li>Formatter Example \u2014 List of the available formatters with the corresponding configs that can be inserted into <code>treefmt.toml</code></li> </ol>"},{"location":"installation/","title":"Installation","text":"<p>There are two options to install <code>treefmt</code>: by downloading the latest binary, or by compiling and building the tool from source.</p>"},{"location":"installation/#installing-with-a-binary-file","title":"Installing with a binary file","text":"<p>You can find the list of the latest binaries here.</p>"},{"location":"installation/#building-from-source","title":"Building from source","text":"<p>There are several ways to build <code>treefmt</code> from source. Your choice will depend on whether you're a nix user.</p>"},{"location":"installation/#non-nix-user","title":"Non-Nix User","text":"<p>To try the project without building it, run:</p> <pre><code>$ cargo run -- --help\n</code></pre> <p>The command will output the manual. You can run the tool in this manner with any other flag or option to format your project.</p> <p>To build a binary, you need to have rust installed. You can install it with rustup. Now, if you want to build the project, switch to the project root folder and run:</p> <pre><code>$ cargo build\n</code></pre> <p>After the successful execution of the cargo build command, you will find the <code>treefmt</code> binary in the target folder.</p>"},{"location":"installation/#nix-user","title":"Nix User","text":"<p>Nix is a package manager foundational for NixOS. You can use it in NixOS and in any other OS equally.</p> <p>If you're using both <code>treefmt</code> and <code>nix</code>, you can go for <code>treefmt-nix</code>, a special tool that makes installation and configuration of <code>treefmt</code> with <code>nix</code> easier.</p> <p>Non-flake user</p> <p>Here you also have two options: you can install <code>treefmt</code> with plain nix-build , or with nix-shell.</p> <p>To build the package with nix-build, just run:</p> <pre><code>$ nix-build -A treefmt\n</code></pre> <p>Nix-flake user</p> <p>If you want to use this repository with flakes, please enable the flakes feature first. To run the project with flakes without building it, you can execute the following command in the root folder:</p> <pre><code>$ nix run . -- --help\n</code></pre> <p>To build the project, run the following command in the root folder:</p> <pre><code>$ nix build\n</code></pre> <p>The <code>treefmt</code> binary will be available in the result folder.</p>"},{"location":"integrations/","title":"Integrations","text":"<p>add your project here.</p> <p>Here is a list of projects that integrate with treefmt.</p>"},{"location":"integrations/#the-vim-null-ls-plugin","title":"the vim null-ls plugin","text":"<p>See https://github.com/jose-elias-alvarez/null-ls.nvim/pull/1512 for usage.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>To run <code>treefmt</code> in your project, please follow these steps:</p> <ol> <li>Install the tool.</li> <li>Install the needed formatters.</li> <li>Run <code>treefmt --init</code>. This will generate the basic configuration file <code>treefmt.toml</code> containing the formatting rules.</li> <li>Edit the configuration (see here how).</li> <li>Run <code>treefmt</code> with the needed flags and options. You can check the supported options by executing <code>treefmt --help</code>.</li> </ol> <p>In the following sections we will guide you through installing and configuring <code>treefmt</code> in detail.</p>"},{"location":"treefmt-configuration/","title":"Configuration","text":"<p><code>treefmt</code> can only be run in the presence of <code>treefmt.toml</code> where files are mapped to specific code formatters.</p> <p>Usually the config file sits in the project root folder. If you're running <code>treefmt</code> in one of the project's folders, then <code>treefmt</code> will look for the config in the parent folders up until the project's root. However, you can place the config anywhere in your project's file tree and specify the path in the ---config-file flag.</p> <p>The typical section of <code>treefmt.toml</code> looks like this:</p> <pre><code>[formatter.&lt;name&gt;]\ncommand = \"&lt;formatter-command&gt;\"\noptions = [\"&lt;formatter-option-1&gt;\"...]\nincludes = [\"&lt;glob-pattern&gt;\"...]\n</code></pre> <p>...where name is just an identifier.</p> <pre><code>[formatter.elm]\ncommand = \"elm-format\"\noptions = [\"--yes\"]\nincludes = [\"*.elm\"]\n</code></pre> <p>Make sure you installed all the formatters specified in the config before running <code>treefmt</code>. If you don't want to install all formatters, you can still run <code>treefmt</code> by specifying the flag <code>--allow-missing-formatter</code>. This will make the program not error out if the needed formatter is missing.</p>"},{"location":"treefmt-configuration/#configuration-format","title":"Configuration format","text":""},{"location":"treefmt-configuration/#formattername","title":"<code>[formatter.&lt;name&gt;]</code>","text":"<p>This section describes the integration between a single formatter and treefmt. \"Name\" here is a unique ID of your formatter in the config file. It doesn't have to match the formatter name.</p> <ul> <li><code>command</code>: A list of arguments to be executed. This will be concatenated with the options attribute during invocation. The first argument is the name of the executable to run.</li> <li><code>options</code>: A list of extra arguments to add to the command. These are typically project-specific arguments.</li> <li> <p><code>includes</code>: A list of glob patterns to match file names, including extensions and paths, used to select specific files for formatting. Typically, only file extensions are specified to pick all files written in a specific language. For instance,[<code>\"*.sh\"</code>] selects shell script files. But sometimes, you may need to specify a full file name, like [<code>\"Makefile\"</code>], or a pattern picking files in a specific folder, like [<code>\"/home/user/project/*\"</code>].</p> </li> <li> <p><code>excludes</code>: A list of glob patterns to exclude from formatting. If any of these patterns match, the file will be excluded from formatting by a particular formatter.</p> </li> </ul>"},{"location":"treefmt-configuration/#global","title":"<code>[global]</code>","text":"<p>This section describes the configuration properties that apply to every formatter.</p> <ul> <li><code>excludes</code>: A list of glob patterns to deny. If any of these patterns match, the file won't be formatted. This list is appended to the individual formatter's excludes lists.</li> </ul>"},{"location":"usage/","title":"Usage","text":"<p>You can run treefmt by executing:</p> <p><code>$ treefmt</code></p> <p>or, if it's not in your <code>$PATH</code>:</p> <p><code>$ ./treefmt</code></p> <p>Treefmt has the following specification:</p> <pre><code>treefmt [FLAGS] [OPTIONS] [--] [paths]...\n</code></pre>"},{"location":"usage/#flags","title":"Flags","text":"<p><code>--allow-missing-formatter</code></p> <p>Do not exit with an error if some of the configured formatters are missing.</p> <p><code>--clear-cache</code></p> <p>Reset the evaluation cache. Invalidation should happen automatically if the formatting tool has been updated, or if the files to format have changed. If cache wasn't properly invalidated, you can use this flag to clear the cache.</p> <p><code>--fail-on-change</code></p> <p>Exit with error if some files require re-formatting. This is useful for your CI if you want to detect if the contributed code was forgotten to be formatted.</p> <p><code>-h, --help</code></p> <p>Prints available flags and options</p> <p><code>--init</code></p> <p>Creates a new config file <code>treefmt.toml</code>.</p> <p><code>--no-cache</code></p> <p>Tells <code>treefmt</code> to ignore the evaluation cache entirely. With this flag, you can avoid cache invalidation issues, if any. Typically, the machine that is running treefmt in the CI is starting with a fresh environment each time, so any calculated cache is lost. The <code>--no-cache</code> flag eliminates unnecessary work in the CI.</p> <p><code>-q, --quiet</code></p> <p>Don't print output to stderr.</p> <p><code>--stdin</code></p> <p>Format the content passed in stdin.</p> <p><code>-V, --version</code></p> <p>Print version information.</p> <p><code>-v, --verbose</code></p> <p>Change the log verbosity. Log verbosity is based off the number of 'v' used. With one <code>-v</code>, your logs will display <code>[INFO]</code> and <code>[ERROR]</code> messages, while <code>-vv</code> will also show <code>[DEBUG]</code> messages.</p> <p><code>--config-file &lt;config-file&gt;</code></p> <p>Run with the specified config file which is not in the project tree.</p> <p><code>-f, --formatters &lt;formatters&gt;...</code></p> <p>Only apply selected formatters. Defaults to all formatters.</p> <p><code>-H, --hidden</code></p> <p>Also traverse hidden files (files that start with a .). This behaviour can be overridden with the <code>--no-hidden</code> flag.</p> <p><code>--no-hidden</code></p> <p>Override the <code>--hidden</code> flag. Don't traverse hidden files.</p> <p><code>--tree-root &lt;tree-root&gt;</code></p> <p>Set the path to the tree root directory where treefmt will look for the files to format. Defaults to the folder holding the <code>treefmt.toml</code> file. It\u2019s mostly useful in combination with <code>--config-file</code> to specify the project root which won\u2019t coincide with the directory holding <code>treefmt.toml</code>.</p> <p><code>-C &lt;work-dir&gt;</code></p> <p>Run as if <code>treefmt</code> was started in <code>&lt;work-dir&gt;</code> instead of the current working directory (default: <code>.</code>). Equivalent to <code>cd &lt;work dir&gt;; treefmt</code>.</p>"},{"location":"usage/#arguments","title":"Arguments","text":"<p><code>&lt;paths&gt;...</code></p> <p>Paths to format. Defaults to formatting the whole tree</p>"},{"location":"usage/#ci-integration","title":"CI integration","text":"<p>Typically, you would use treefmt in the CI with the <code>--fail-on-change</code> and <code>--no-cache flags</code>. Find the explanations above.</p> <p>You can you set a <code>treefmt</code> job in the GitHub pipeline for Ubuntu with nix-shell like this:</p> <pre><code>name: treefmt\non:\n  pull_request:\n  push:\n    branches: main\njobs:\n  formatter:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v1\n    - uses: cachix/install-nix-action@v12\n      with:\n        nix_path: nixpkgs=channel:nixos-unstable\n    - uses: cachix/cachix-action@v10\n      with:\n        name: nix-community\n        authToken: '${{ secrets.CACHIX_AUTH_TOKEN }}'\n    - name: treefmt\n      run: nix-shell --run \"treefmt --fail-on-change --no-cache\"\n</code></pre>"}]}