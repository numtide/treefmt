{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"contributing/code/","title":"Code","text":""},{"location":"contributing/code/#pre-requisites","title":"Pre-requisites","text":"<p>You will need to have the following installed:</p> <ul> <li>Nix</li> <li>Direnv</li> </ul> <p>Important</p> <p>We use a Flake-based workflow. You can certainly develop for <code>treefmt</code> without Flakes and leverage much of what is listed below, but it is left up to the reader to determine how to make that work.</p>"},{"location":"contributing/code/#go-development","title":"Go development","text":"<p>The default devshell provides all the necessary tooling and utilities for working on <code>treefmt</code>.</p> nix/devshells/default.nix<pre><code>{\n  pkgs,\n  perSystem,\n  ...\n}:\npkgs.mkShellNoCC {\n  env.GOROOT = \"${pkgs.go}/share/go\";\n\n  packages =\n    (with pkgs; [\n      go\n      goreleaser\n      golangci-lint\n      delve\n      pprof\n      graphviz\n      cobra-cli\n      enumer\n      perSystem.gomod2nix.default\n    ])\n    ++ # include formatters for development and testing\n    (import ../packages/treefmt/formatters.nix pkgs);\n}\n</code></pre> <p>Direnv should load this by default when entering the root of the repository.</p> <p>For the most part, you should be able to develop normally as you would any other Go program.</p> <p>Important</p> <p>When you have completed making any changes and have tested it as you would any other Go program, it is important to ensure it works when run as a Nix package.</p> <p>This can be done with <code>nix run .# -- &lt;args&gt;</code>, which will build the Nix derivation and execute the resultant <code>treefmt</code> binary.</p>"},{"location":"contributing/code/#formatting","title":"Formatting","text":"<p>We use the latest released version of treefmt and treefmt-nix to format the repository by running <code>nix fmt</code> from the root directory.</p> nix/formatter.nix<pre><code>{\n  pkgs,\n  inputs,\n  ...\n}:\ninputs.treefmt-nix.lib.mkWrapper pkgs {\n  projectRootFile = \"flake.nix\";\n\n  programs = {\n    alejandra.enable = true;\n    deadnix.enable = true;\n    gofumpt.enable = true;\n    prettier.enable = true;\n    statix.enable = true;\n  };\n\n  settings = {\n    global.excludes = [\n      \"LICENSE\"\n      # let's not mess with the test folder\n      \"test/*\"\n      # unsupported extensions\n      \"*.{gif,png,svg,tape,mts,lock,mod,sum,toml,env,envrc,gitignore,pages}\"\n    ];\n\n    formatter = {\n      deadnix = {\n        priority = 1;\n      };\n\n      statix = {\n        priority = 2;\n      };\n\n      alejandra = {\n        priority = 3;\n      };\n\n      prettier = {\n        options = [\n          \"--tab-width\"\n          \"4\"\n        ];\n        includes = [\"*.{css,html,js,json,jsx,md,mdx,scss,ts,yaml}\"];\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"contributing/code/#checks","title":"Checks","text":"<p>Running <code>nix flake check</code> will build all the devshells and Nix packages, as well as check the formatting with treefmt and any other Flake checks that have been configured.</p>"},{"location":"contributing/code/#documentation","title":"Documentation","text":"<p>When making changes, it is important to add or update any relevant sections in the documentation within the same pull request.</p> <p>For more information see the next section.</p>"},{"location":"contributing/docs/","title":"Documentation","text":"<p>There is a separate devshell called <code>docs</code> which is provided for working with the docs locally.</p> <p>It can be entered by running: <code>nix develop .#docs</code></p> nix/devshells/docs.nix<pre><code>\n</code></pre> <p>The docs are based on MkDocs and the MkDocs Material theme. You will find its configuration and content in the following locations:</p> <ul> <li><code>mkdocs.yaml</code></li> <li><code>./docs</code></li> </ul>"},{"location":"contributing/docs/#serve-locally","title":"Serve locally","text":"<p>To serve the docs locally run <code>mkdocs serve</code> from the root of the repository:</p> <pre><code>\u276f mkdocs serve\nINFO    -  Building documentation...\nINFO    -  Cleaning site directory\nWARNING -  The following pages exist in the docs directory, but are not included in the \"nav\" configuration:\n             - index.md\nINFO    -  Documentation built in 0.26 seconds\nINFO    -  [16:22:36] Watching paths for changes: 'docs/content', 'mkdocs.yml'\nINFO    -  [16:22:36] Serving on http://127.0.0.1:8000/treefmt/\n</code></pre>"},{"location":"contributing/docs/#versioning-publication","title":"Versioning &amp; Publication","text":"<p>Versioning of the docs is managed through mike.</p> <p>It is responsible for managing the structure of the <code>gh-pages</code> branch in the repository, which Github Pages is configured to serve from.</p> <p>Note</p> <p>More information about versioning with MkDocs Material and mike can be found here.</p> <p>There is a github workflow, <code>.github/workflows/gh-pages.yml</code> which is responsible for publishing the docs. It does the following:</p> <ul> <li>On merge to <code>main</code>, the docs version main is updated.</li> <li>When a new tag is created of the form <code>v.&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code> a docs version <code>v&lt;major&gt;.&lt;minor&gt;</code> is created and the     latest alias is updated to point to this.</li> </ul> <p>The idea is that users will land on the latest released version of the docs by default, with <code>main</code> being available if they wish to read about unreleased features and changes.</p> <p>To preview the versions locally you can use <code>mike serve</code> instead of <code>mkdocs serve</code>.</p> <p>Warning</p> <p>Be sure to have fetched the latest changes for the <code>gh-pages</code> branch first. This is especially important if you are using <code>mike</code> locally to make manual changes to the published site.</p>"},{"location":"getting-started/configure/","title":"Configure","text":"<p><code>treefmt</code>'s behaviour can be influenced in one of three ways:</p> <ol> <li>Process flags and arguments</li> <li>Environment variables</li> <li>A TOML based config file</li> </ol> <p>There is an order of precedence between these mechanisms as listed above, with process flags having the highest precedence and values in the configuration file having the lowest.</p> <p>Note</p> <p>Some options can only be configured as process flags, others may support process flags and environment variables, and others still may support all three mechanisms.</p>"},{"location":"getting-started/configure/#config-file","title":"Config File","text":"<p>The <code>treefmt</code> configuration file is a mixture of global options and formatter sections.</p> <p>It should be named <code>treefmt.toml</code> or <code>.treefmt.toml</code>, and typically resides at the root of a repository.</p> <p>When executing <code>treefmt</code> within a subdirectory, <code>treefmt</code> will search upwards in the directory structure, looking for <code>treefmt.toml</code> or <code>.treefmt.toml</code>. You can change this behaviour using the config-file options</p> <p>Tip</p> <p>When starting a new project you can generate an initial config file using <code>treefmt --init</code></p> treefmt.toml<pre><code># The formatter multiplexer - https://github.com/numtide/treefmt\n\n# Do not exit with error if a configured formatter is missing\n# Env $TREEFMT_ALLOW_MISSING_FORMATTER\n# allow-missing-formatter = true\n\n# The file into which a cpu profile will be written\n# Env $TREEFMT_CPU_PROFILE\n# cpu-profile = ./cpu.pprof\n\n# Exclude files or directories matching the specified globs\n# Env $TREEFMT_EXCLUDES\n# excludes = [\"*.md\", \"*.gif\"]\n\n# Exit with error if any changes were made during execution\n# Useful for CI\n# Env $TREEFMT_FAIL_ON_CHANGE\n# fail-on-change = true\n\n# A list of formatters to apply\n# Defaults to all configured formatters\n# Env $TREEFMT_FORMATTERS\n# formatters = [\"gofmt\", \"prettier\"]\n\n# Log paths that did not match any formatters at the specified log level\n# Possible values are &lt;debug|info|warn|error|fatal&gt;\n# Env $TREEFMT_ON_UNMATCHED\n# on-unmatched = \"info\"\n\n# The root directory from which treefmt will start walking the filesystem\n# Defaults to the directory containing the config file\n# Env $TREEFMT_TREE_ROOT\n# tree-root = \"/tmp/foo\"\n\n# File to search for to find the tree root (if tree-root is not set)\n# Env $TREEFMT_TREE_ROOT_FILE\n# tree-root-file = \".git/config\"\n\n# Set the verbosity of logs\n# 0 = warn, 1 = info, 2 = debug\n# Env $TREEFMT_VERBOSE\n# verbose = 2\n\n# The method used to traverse the files within the tree root\n# Currently, we support 'auto', 'git' or 'filesystem'\n# Env $TREEFMT_WALK\n# walk = \"filesystem\"\n\n[formatter.mylanguage]\n# Command to execute\ncommand = \"command-to-run\"\n# Command-line arguments for the command\noptions = []\n# Glob pattern of files to include\nincludes = [ \"*.&lt;language-extension&gt;\" ]\n# Glob patterns of files to exclude\nexcludes = []\n# Controls the order of application when multiple formatters match the same file\n# Lower the number, the higher the precedence\n# Default is 0\npriority = 0\n</code></pre>"},{"location":"getting-started/configure/#global-options","title":"Global Options","text":""},{"location":"getting-started/configure/#allow-missing-formatter","title":"<code>allow-missing-formatter</code>","text":"<p>Do not exit with error if a configured formatter is missing.</p> FlagEnvConfig <pre><code>treefmt --allow-missing-formatter true\n</code></pre> <pre><code>TREEFMT_ALLOW_MISSING_FORMATTER=true treefmt\n</code></pre> <pre><code>allow-missing-formatter = true\n</code></pre>"},{"location":"getting-started/configure/#ci","title":"<code>ci</code>","text":"<p>Runs treefmt in a CI mode, enabling no-cache, fail-on-change and adjusting some other settings best suited to a continuous integration environment.</p> FlagEnv <pre><code>treefmt --ci\n</code></pre> <pre><code>TREEFMT_CI=true treefmt\n</code></pre>"},{"location":"getting-started/configure/#clear-cache","title":"<code>clear-cache</code>","text":"<p>Reset the evaluation cache. Use in case the cache is not precise enough.</p> FlagEnv <pre><code>treefmt -c\ntreefmt --clear-cache\n</code></pre> <pre><code>TREEFMT_CLEAR_CACHE=true treefmt\n</code></pre>"},{"location":"getting-started/configure/#config-file_1","title":"<code>config-file</code>","text":"FlagEnv <pre><code>treefmt --config-file /tmp/treefmt.toml\n</code></pre> <pre><code>TREEFMT_CONFIG=/tmp/treefmt.toml treefmt\n</code></pre>"},{"location":"getting-started/configure/#cpu-profile","title":"<code>cpu-profile</code>","text":"<p>The file into which a pprof cpu profile will be written.</p> FlagEnvConfig <pre><code>treefmt --cpu-profile ./cpu.pprof\n</code></pre> <pre><code>TREEFMT_CPU_PROFILE=./cpu.pprof treefmt\n</code></pre> <pre><code>cpu-profile = \"./cpu.pprof\"\n</code></pre>"},{"location":"getting-started/configure/#excludes","title":"<code>excludes</code>","text":"<p>An optional list of glob patterns used to exclude files from all formatters.</p> FlagEnvConfig <pre><code>treefmt --excludes *.toml,*.php,README\n</code></pre> <pre><code>TREEFMT_EXCLUDES=\"*.toml,*.php,README\" treefmt\n</code></pre> <pre><code>excludes = [\"*.toml\", \"*.php\", \"README\"]\n</code></pre>"},{"location":"getting-started/configure/#fail-on-change","title":"<code>fail-on-change</code>","text":"<p>Exit with error if any changes were made during execution.</p> FlagEnvConfig <pre><code>treefmt --fail-on-change true\n</code></pre> <pre><code>TREEFMT_FAIL_ON_CHANGE=true treefmt\n</code></pre> <pre><code>fail-on-change = true\n</code></pre>"},{"location":"getting-started/configure/#formatters","title":"<code>formatters</code>","text":"<p>A list of formatters to apply. Defaults to all configured formatters.</p> FlagEnvConfig <pre><code>treefmt -f go,toml,haskell\ntreefmt --formatters go,toml,haskell\n</code></pre> <pre><code>TREEFMT_FORMATTERS=go,toml,haskell treefmt\n</code></pre> <pre><code>formatters = [\"go\", \"toml\", \"haskell\"]\n\n[formatter.go]\n...\n\n[formatter.toml]\n...\n\n[formatter.haskell]\n...\n\n[formatter.ruby]\n...\n\n[formatter.shellcheck]\n...\n</code></pre>"},{"location":"getting-started/configure/#no-cache","title":"<code>no-cache</code>","text":"<p>Ignore the evaluation cache entirely. Useful for CI.</p> FlagEnv <pre><code>treefmt --no-cache\n</code></pre> <pre><code>TREEFMT_NO_CACHE=true treefmt\n</code></pre>"},{"location":"getting-started/configure/#on-unmatched","title":"<code>on-unmatched</code>","text":"<p>Log paths that did not match any formatters at the specified log level. Possible values are <code>&lt;debug|info|warn|error|fatal&gt;</code>.</p> <p>Warning</p> <p>If you select <code>fatal</code>, the process will exit immediately with a non-zero exit.</p> FlagEnvConfig <pre><code>treefmt -u debug\ntreefmt --on-unmatched debug\n</code></pre> <pre><code>TREEFMT_ON_UNMACTHED=info treefmt\n</code></pre> <pre><code>on-unmatched = \"debug\"\n</code></pre>"},{"location":"getting-started/configure/#stdin","title":"<code>stdin</code>","text":"<p>Format the context passed in via stdin.</p> <p>Note</p> <p>You must provide a single path argument, the value of which is used to match against the configured formatters.</p> Flag <pre><code>cat ../test.go | treefmt --stdin foo.go\n</code></pre>"},{"location":"getting-started/configure/#tree-root","title":"<code>tree-root</code>","text":"<p>The root directory from which treefmt will start walking the filesystem. Defaults to the directory containing the config file.</p> FlagEnvConfig <pre><code>treefmt --tree-root /tmp/foo\n</code></pre> <pre><code>TREEFMT_TREE_ROOT=/tmp/foo treefmt\n</code></pre> <pre><code>tree-root = \"/tmp/foo\"\n</code></pre>"},{"location":"getting-started/configure/#tree-root-file","title":"<code>tree-root-file</code>","text":"<p>File to search for to find the tree root (if <code>tree-root</code> is not set)</p> FlagEnvConfig <pre><code>treefmt --tree-root-file .git/config\n</code></pre> <pre><code>TREEFMT_TREE_ROOT_FILE=.git/config treefmt\n</code></pre> <pre><code>tree-root-file = \".git/config\"\n</code></pre>"},{"location":"getting-started/configure/#verbose","title":"<code>verbose</code>","text":"<p>Set the verbosity level of logs:</p> <ul> <li><code>0</code> =&gt; <code>warn</code></li> <li><code>1</code> =&gt; <code>info</code></li> <li><code>2</code> =&gt; <code>debug</code></li> </ul> FlagEnvConfig <p>The number of <code>v</code>'s passed matches the level set.</p> <pre><code>treefmt -vv\n</code></pre> <pre><code>TREEFMT_VERBOSE=1 treefmt\n</code></pre> <pre><code>verbose = 2\n</code></pre>"},{"location":"getting-started/configure/#walk","title":"<code>walk</code>","text":"<p>The method used to traverse the files within the tree root. Currently, we support 'auto', 'git' or 'filesystem'</p> FlagEnvConfig <pre><code>treefmt --walk filesystem\n</code></pre> <pre><code>TREEFMT_WALK=filesystem treefmt\n</code></pre> <pre><code>walk = \"filesystem\"\n</code></pre>"},{"location":"getting-started/configure/#working-dir","title":"<code>working-dir</code>","text":"<p>Run as if <code>treefmt</code> was started in the specified working directory instead of the current working directory.</p> FlagEnv <pre><code>treefmt -C /tmp/foo\ntreefmt --working-dir /tmp/foo\n</code></pre> <pre><code>TREEFMT_WORKING_DIR=/tmp/foo treefmt\n</code></pre>"},{"location":"getting-started/configure/#formatter-options","title":"Formatter Options","text":"<p>Formatters are configured using a table entry in <code>treefmt.toml</code> of the form <code>[formatter.&lt;name&gt;]</code>:</p> <pre><code>[formatter.alejandra]\ncommand = \"alejandra\"\nincludes = [\"*.nix\"]\nexcludes = [\"examples/nix/sources.nix\"]\npriority = 1\n\n[formatter.deadnix]\ncommand = \"deadnix\"\noptions = [\"-e\"]\nincludes = [\"*.nix\"]\npriority = 2\n</code></pre>"},{"location":"getting-started/configure/#command","title":"<code>command</code>","text":"<p>The command to invoke when applying the formatter.</p>"},{"location":"getting-started/configure/#options","title":"<code>options</code>","text":"<p>An optional list of args to be passed to <code>command</code>.</p>"},{"location":"getting-started/configure/#includes","title":"<code>includes</code>","text":"<p>A list of glob patterns used to determine whether the formatter should be applied against a given path.</p>"},{"location":"getting-started/configure/#excludes_1","title":"<code>excludes</code>","text":"<p>An optional list of glob patterns used to exclude certain files from this formatter.</p>"},{"location":"getting-started/configure/#priority","title":"<code>priority</code>","text":"<p>Influences the order of execution. Greater precedence is given to lower numbers, with the default being <code>0</code>.</p>"},{"location":"getting-started/configure/#same-file-multiple-formatters","title":"Same file, multiple formatters?","text":"<p>For each file, <code>treefmt</code> determines a list of formatters based on the configured <code>includes</code> / <code>excludes</code> rules. This list is then sorted, first by priority (lower the value, higher the precedence) and secondly by formatter name (lexicographically).</p> <p>The resultant sequence of formatters is used to create a batch key, and similarly matched files get added to that batch until it is full, at which point the files are passed to each formatter in turn.</p> <p>This means that <code>treefmt</code> guarantees only one formatter will be operating on a given file at any point in time. Another consequence is that formatting is deterministic for a given file and a given <code>treefmt</code> configuration.</p> <p>By setting the priority fields appropriately, you can control the order in which those formatters are applied for any files they both happen to match on.</p>"},{"location":"getting-started/configure/#glob-patterns-format","title":"Glob patterns format","text":"<p>This is a variant of the Unix glob pattern. It supports all the usual selectors such as <code>*</code> and <code>?</code>.</p>"},{"location":"getting-started/configure/#examples","title":"Examples","text":"<ul> <li><code>*.go</code> - match all files in the project that end with a \".go\" file extension.</li> <li><code>vendor/*</code> - match all files under the vendor folder, recursively.</li> </ul>"},{"location":"getting-started/configure/#supported-formatters","title":"Supported Formatters","text":"<p>Any formatter that follows the spec is supported out of the box.</p> <p>Already 60+ formatters are supported.</p> <p>To find examples, take a look at https://github.com/numtide/treefmt-nix/tree/main/examples.</p> <p>If you are a Nix user, you might also like https://github.com/numtide/treefmt-nix, which uses Nix to pull in the right formatter package and seamlessly integrates both together.</p>"},{"location":"getting-started/install/","title":"Install","text":"<p>There are two ways to install <code>treefmt</code>:</p> <ol> <li>Download the latest binary</li> <li>Compile and build from source.</li> </ol>"},{"location":"getting-started/install/#download-a-binary-file","title":"Download a binary file","text":"<p>You can download the latest <code>treefmt</code> binaries here.</p>"},{"location":"getting-started/install/#build-from-source","title":"Build from source","text":"<p>There are several ways to build <code>treefmt</code> from source. Your choice will depend on whether you're a nix user or not.</p>"},{"location":"getting-started/install/#non-nix-user","title":"Non-Nix User","text":"<p>To try the project without building it, run the following from the project root folder:</p> <pre><code>$ go run main.go --help\n</code></pre> <p>This command will output the manual. You can run the tool in this manner with any other flag or option to format your project.</p> <p>To build a binary, you need to have <code>go 1.22</code> installed. You can find instructions on how to install a <code>go</code> compiler here.</p> <p>To build the project, run the following:</p> <pre><code>$ go build\n</code></pre> <p>After the build command exits successfully, you will find the <code>treefmt</code> binary in the project root folder.</p>"},{"location":"getting-started/install/#nix-user","title":"Nix User","text":"<p>If you're using both <code>treefmt</code> and <code>nix</code>, you can make use of <code>treefmt-nix</code>, a wrapper that makes installing and configuring <code>treefmt</code> with <code>nix</code> easier.</p> <p>Non-flake user</p> <p>Here you also have two options: you can install <code>treefmt</code> with plain <code>nix-build</code>, or with <code>nix-shell</code>.</p> <p>To build the package with <code>nix-build</code>, run the following:</p> <pre><code>$ nix-build -A packages.x86_64-linux.treefmt\n</code></pre> <p>note: substitute <code>x86_64-linux</code> for the target system you with to build for</p> <p>Nix-flake user</p> <p>If you want to use this repository with flakes, first ensure you have flakes enabled. You can then execute the following command in the project root folder:</p> <pre><code>$ nix run . -- --help\n</code></pre> <p>To build the project, run the following command in the project root folder:</p> <pre><code>$ nix build\n</code></pre> <p>The <code>treefmt</code> binary will be available in the <code>result</code> folder.</p>"},{"location":"getting-started/usage/","title":"Usage","text":"<p><code>treefmt</code> has the following specification:</p> <pre><code>Usage:\n  treefmt &lt;paths...&gt; [flags]\n\nFlags:\n      --allow-missing-formatter   Do not exit with error if a configured formatter is missing. (env $TREEFMT_ALLOW_MISSING_FORMATTER)\n      --ci                        Runs treefmt in a CI mode, enabling --no-cache, --fail-on-change and adjusting some other settings best suited to a CI use case. (env $TREEFMT_CI)\n  -c, --clear-cache               Reset the evaluation cache. Use in case the cache is not precise enough. (env $TREEFMT_CLEAR_CACHE)\n      --config-file string        Load the config file from the given path (defaults to searching upwards for treefmt.toml or .treefmt.toml).\n      --cpu-profile string        The file into which a cpu profile will be written. (env $TREEFMT_CPU_PROFILE)\n      --excludes strings          Exclude files or directories matching the specified globs. (env $TREEFMT_EXCLUDES)\n      --fail-on-change            Exit with error if any changes were made. Useful for CI. (env $TREEFMT_FAIL_ON_CHANGE)\n  -f, --formatters strings        Specify formatters to apply. Defaults to all configured formatters. (env $TREEFMT_FORMATTERS)\n  -h, --help                      help for treefmt\n  -i, --init                      Create a treefmt.toml file in the current directory.\n      --no-cache                  Ignore the evaluation cache entirely. Useful for CI. (env $TREEFMT_NO_CACHE)\n  -u, --on-unmatched string       Log paths that did not match any formatters at the specified log level. Possible values are &lt;debug|info|warn|error|fatal&gt;. (env $TREEFMT_ON_UNMATCHED) (default \"warn\")\n      --stdin                     Format the context passed in via stdin.\n      --tree-root string          The root directory from which treefmt will start walking the filesystem (defaults to the directory containing the config file). (env $TREEFMT_TREE_ROOT)\n      --tree-root-file string     File to search for to find the tree root (if --tree-root is not passed). (env $TREEFMT_TREE_ROOT_FILE)\n  -v, --verbose count             Set the verbosity of logs e.g. -vv. (env $TREEFMT_VERBOSE)\n      --version                   version for treefmt\n      --walk string               The method used to traverse the files within the tree root. Currently supports &lt;auto|git|filesystem&gt;. (env $TREEFMT_WALK) (default \"auto\")\n  -C, --working-dir string        Run as if treefmt was started in the specified working directory instead of the current working directory. (env $TREEFMT_WORKING_DIR) (default \".\")\n</code></pre> <p>Typically, you will execute <code>treefmt</code> from the root of your repository with no arguments:</p> <pre><code>\u276f treefmt\ntraversed 106 files\nemitted 9 files for processing\nformatted 6 files (2 changed) in 184ms\n</code></pre>"},{"location":"getting-started/usage/#clear-cache","title":"Clear Cache","text":"<p>To force re-evaluation of the entire tree, you run <code>treefmt</code> with the <code>-c</code> or <code>--clear-cache</code> flag:</p> <pre><code>\u276f treefmt -c\ntraversed 106 files\nemitted 106 files for processing\nformatted 56 files (0 changed) in 363ms\n\n\u276f treefmt --clear-cache\ntraversed 106 files\nemitted 106 files for processing\nformatted 56 files (0 changed) in 351ms\n</code></pre>"},{"location":"getting-started/usage/#change-working-directory","title":"Change working directory","text":"<p>Similar to git, <code>treefmt</code> has an option to change working directory before executing:</p> <pre><code>\u276f treefmt -C test/examples --allow-missing-formatter\ntraversed 106 files\nemitted 56 files for processing\nformatted 46 files (1 changed) in 406ms\n</code></pre>"},{"location":"getting-started/usage/#format-files-directories","title":"Format files &amp; directories","text":"<p>To format one or more specific files, you can pass them as arguments.</p> <pre><code>&gt; treefmt default.nix walk/walk.go nix/devshells/renovate.nix\ntraversed 3 files\nemitted 3 files for processing\nformatted 3 files (0 changed) in 144ms\n</code></pre> <p>You can also pass directories:</p> <pre><code>&gt; treefmt nix walk/cache\ntraversed 9 files\nemitted 8 files for processing\nformatted 7 files (0 changed) in 217ms\n</code></pre> <p>Note</p> <p>When passing directories as arguments, <code>treefmt</code> will traverse them using the configured walk strategy.</p>"},{"location":"getting-started/usage/#format-stdin","title":"Format stdin","text":"<p>Using the stdin option, <code>treefmt</code> can format content passed via <code>stdin</code>, forwarding its output to <code>stdout</code>:</p> <pre><code>\u276f cat default.nix | treefmt --stdin foo.nix\n# This file provides backward compatibility to nix &lt; 2.4 clients\n{system ? builtins.currentSystem}: let\n  lock = builtins.fromJSON (builtins.readFile ./flake.lock);\n\n  inherit\n    (lock.nodes.flake-compat.locked)\n    owner\n    repo\n    rev\n    narHash\n    ;\n\n  flake-compat = fetchTarball {\n    url = \"https://github.com/${owner}/${repo}/archive/${rev}.tar.gz\";\n    sha256 = narHash;\n  };\n\n  flake = import flake-compat {\n    inherit system;\n    src = ./.;\n  };\nin\n  flake.defaultNix\n</code></pre>"},{"location":"getting-started/usage/#ci-integration","title":"CI integration","text":"<p>We recommend using the CI option in continuous integration environments.</p> <p>You can configure a <code>treefmt</code> job in a GitHub pipeline for Ubuntu with <code>nix-shell</code> like this:</p> <pre><code>name: treefmt\non:\n    pull_request:\n    push:\n        branches: main\njobs:\n    formatter:\n        runs-on: ubuntu-latest\n        steps:\n            - uses: actions/checkout@v4\n            - uses: cachix/install-nix-action@v26\n              with:\n                  nix_path: nixpkgs=channel:nixos-unstable\n            - uses: cachix/cachix-action@v14\n              with:\n                  name: nix-community\n                  authToken: \"${{ secrets.CACHIX_AUTH_TOKEN }}\"\n            - name: treefmt\n              run: nix-shell -p treefmt --run \"treefmt --ci\"\n</code></pre>"},{"location":"guides/unmatched-formatters/","title":"Handling Unmatched Files","text":"<p>By default, treefmt lists all files that aren't matched by any formatter:</p> <pre><code>$ treefmt\nWARN no formatter for path: .gitignore\nWARN no formatter for path: LICENSE\nWARN no formatter for path: README.md\nWARN no formatter for path: go.mod\nWARN no formatter for path: go.sum\nWARN no formatter for path: build/build.go\n# ...\n</code></pre> <p>This helps you decide whether to add formatters for specific files or ignore them entirely.</p>"},{"location":"guides/unmatched-formatters/#customizing-notifications","title":"Customizing Notifications","text":""},{"location":"guides/unmatched-formatters/#reducing-log-verbosity","title":"Reducing Log Verbosity","text":"<p>If you find the unmatched file warnings too noisy, you can lower the logging level in your config:</p> <p><code>treefmt.toml</code>: <pre><code>on-unmatched = \"debug\"\n</code></pre></p> <p>To later find out what files are unmatched, you can override this setting via the command line: <pre><code>$ treefmt --on-unmatched warn\n</code></pre></p>"},{"location":"guides/unmatched-formatters/#enforcing-strict-matching","title":"Enforcing Strict Matching","text":"<p>Another stricter policy approach is to fail the run if any unmatched files are found. This can be paired with an <code>excludes</code> list to ignore specific files:</p> <p><code>treefmt.toml</code>: <pre><code># Fail if any unmatched files are found\non-unmatched = \"fatal\"\n\n# List files to explicitly ignore\nexcludes = [\n  \"LICENCE\",\n  \"go.sum\",\n]\n</code></pre></p>"},{"location":"reference/formatter-spec/","title":"Formatter Specification","text":"<p>To keep the design of <code>treefmt</code> simple, we only support formatters that adhere to a certain standard. This document outlines that standard.</p> <p>In this design, we rely on <code>treefmt</code> to do the tree traversal, and only invoke the code formatter on the selected files.</p> <p>Note</p> <p>If the formatter you would like to use doesn't comply with the rules, it's often possible to create a wrapper script that transforms the usage to match the specification.</p>"},{"location":"reference/formatter-spec/#rules","title":"Rules","text":"<p>In order for the formatter to comply with this spec, it MUST satisfy the following:</p>"},{"location":"reference/formatter-spec/#1-files-passed-as-arguments","title":"1. Files passed as arguments","text":"<p>The formatter's CLI must be of the form:</p> <pre><code>&lt;command&gt; [options] [...&lt;files&gt;]\n</code></pre> <p>Where:</p> <ul> <li><code>&lt;command&gt;</code> is the name of the formatting tool.</li> <li><code>[options]</code> is any number of flags and options that the formatter accepts.</li> <li><code>[...&lt;files&gt;]</code> is one or more files given to the formatter for processing.</li> </ul> <p>Example:</p> <pre><code>$ rustfmt --edition 2018 src/main.rs src/lib.rs\n</code></pre> <p>Note</p> <p>It MUST process the specified files. For example, it MUST NOT ignore files because they are not tracked by a VCS.</p> <p>It SHOULD processes only the specified files. Files that are not passed SHOULD never be formatted.</p>"},{"location":"reference/formatter-spec/#2-write-to-changed-files","title":"2. Write to changed files","text":"<p>Whenever there is a change to the code formatting, the code formatter MUST write those changes back to the original location.</p> <p>If there are no changes to the original file, the formatter MUST NOT write to the original location.</p>"},{"location":"reference/formatter-spec/#3-idempotent","title":"3. Idempotent","text":"<p>The code formatter SHOULD be indempotent. Meaning that it produces stable outputs.</p>"},{"location":"reference/formatter-spec/#4-reliable","title":"4. Reliable","text":"<p>We expect the formatter to be reliable and not break the semantics of the formatted files.</p>"}]}