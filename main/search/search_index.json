{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"contributing/code/","title":"Code","text":""},{"location":"contributing/code/#pre-requisites","title":"Pre-requisites","text":"<p>You will need to have the following installed:</p> <ul> <li>Nix</li> <li>Direnv</li> </ul> <p>Important</p> <p>We use a Flake-based workflow. You can certainly develop for <code>treefmt</code> without Flakes and leverage much of what is listed below, but it is left up to the reader to determine how to make that work.</p>"},{"location":"contributing/code/#go-development","title":"Go development","text":"<p>The default devshell provides all the necessary tooling and utilities for working on <code>treefmt</code>.</p> nix/devshells/default.nix<pre><code>{pkgs, ...}:\npkgs.mkShellNoCC {\n  env = {\n    GOROOT = \"${pkgs.go_1_24}/share/go\";\n    CGO_ENABLED = \"0\";\n  };\n\n  packages =\n    (with pkgs; [\n      go_1_24\n      goreleaser\n      golangci-lint\n      delve\n      pprof\n      graphviz\n      cobra-cli\n      enumer\n      jujutsu\n    ])\n    ++ # include formatters for development and testing\n    (import ../packages/treefmt/formatters.nix pkgs);\n}\n</code></pre> <p>Direnv should load this by default when entering the root of the repository.</p> <p>For the most part, you should be able to develop normally as you would any other Go program.</p> <p>Important</p> <p>When you have completed making any changes and have tested it as you would any other Go program, it is important to ensure it works when run as a Nix package.</p> <p>This can be done with <code>nix run .# -- &lt;args&gt;</code>, which will build the Nix derivation and execute the resultant <code>treefmt</code> binary.</p>"},{"location":"contributing/code/#formatting","title":"Formatting","text":"<p>We use the latest released version of treefmt and treefmt-nix to format the repository by running <code>nix fmt</code> from the root directory.</p> nix/formatter.nix<pre><code>{\n  pkgs,\n  inputs,\n  ...\n}:\ninputs.treefmt-nix.lib.mkWrapper pkgs {\n  projectRootFile = \"flake.nix\";\n\n  programs = {\n    alejandra.enable = true;\n    deadnix.enable = true;\n    gofumpt.enable = true;\n    prettier.enable = true;\n    statix.enable = true;\n  };\n\n  settings = {\n    global.excludes = [\n      \"LICENSE\"\n      # let's not mess with the test folder\n      \"test/*\"\n      # unsupported extensions\n      \"*.{gif,png,svg,tape,mts,lock,mod,sum,toml,env,envrc,gitignore,pages}\"\n    ];\n\n    formatter = {\n      deadnix = {\n        priority = 1;\n      };\n\n      statix = {\n        priority = 2;\n      };\n\n      alejandra = {\n        priority = 3;\n      };\n\n      prettier = {\n        options = [\n          \"--tab-width\"\n          \"4\"\n        ];\n        includes = [\"*.{css,html,js,json,jsx,md,mdx,scss,ts,yaml}\"];\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"contributing/code/#checks","title":"Checks","text":"<p>Running <code>nix flake check</code> will build all the devshells and Nix packages, as well as check the formatting with treefmt and any other Flake checks that have been configured.</p>"},{"location":"contributing/code/#documentation","title":"Documentation","text":"<p>When making changes, it is important to add or update any relevant sections in the documentation within the same pull request.</p> <p>For more information see the next section.</p>"},{"location":"contributing/docs/","title":"Documentation","text":"<p>There is a <code>docs</code> package which can be built as follows:</p> <pre><code>\u276f nix build .#docs\n</code></pre> <p>This produces a static build of the docs and places it in a symlink called <code>result</code> in the same directory.</p> <p>We can re-use this package as a devshell, relying upon it to provide the necessary dependencies for developing the docs.</p> nix/devshells/docs.nix<pre><code>{\n  pkgs,\n  perSystem,\n  ...\n}:\npkgs.stdenvNoCC.mkDerivation {\n  name = \"docs\";\n\n  src = ../../.;\n\n  nativeBuildInputs =\n    [\n      perSystem.self.treefmt\n    ]\n    ++ (with pkgs.python3Packages; [\n      mike\n      mkdocs\n      mkdocs-material\n      mkdocs-awesome-pages-plugin\n    ])\n    ++ [\n      (pkgs.writeShellApplication {\n        name = \"vhs\";\n        runtimeInputs =\n          [\n            perSystem.self.treefmt\n            pkgs.rsync\n            pkgs.vhs\n          ]\n          ++ (import ./treefmt/formatters.nix pkgs);\n        text = ''vhs \"$@\"'';\n      })\n    ];\n\n  buildPhase = ''\n    cd docs\n    mkdocs build\n  '';\n\n  installPhase = ''\n    mv out $out\n  '';\n}\n</code></pre> <p>The docs are based on MkDocs and the MkDocs Material theme.</p>"},{"location":"contributing/docs/#serve-locally","title":"Serve locally","text":"<p>To serve the docs locally run <code>mkdocs serve</code> from the <code>docs</code> directory:</p> <pre><code>\u276f mkdocs serve\nINFO    -  Building documentation...\nINFO    -  Cleaning site directory\nWARNING -  The following pages exist in the docs directory, but are not included in the \"nav\" configuration:\n             - index.md\nINFO    -  Documentation built in 0.26 seconds\nINFO    -  [16:22:36] Watching paths for changes: 'docs/content', 'mkdocs.yml'\nINFO    -  [16:22:36] Serving on http://127.0.0.1:8000/treefmt/\n</code></pre>"},{"location":"contributing/docs/#versioning-publication","title":"Versioning &amp; Publication","text":"<p>Versioning of the docs is managed through mike.</p> <p>It is responsible for managing the structure of the <code>gh-pages</code> branch in the repository, which Github Pages is configured to serve from.</p> <p>Note</p> <p>More information about versioning with MkDocs Material and mike can be found here.</p> <p>There is a github workflow, <code>.github/workflows/gh-pages.yml</code> which is responsible for publishing the docs. It does the following:</p> <ul> <li>On merge to <code>main</code>, the docs version main is updated.</li> <li>When a new tag is created of the form <code>v.&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code> a docs version <code>v&lt;major&gt;.&lt;minor&gt;</code> is created and the   latest alias is updated to point to this.</li> </ul> <p>The idea is that users will land on the latest released version of the docs by default, with <code>main</code> being available if they wish to read about unreleased features and changes.</p> <p>To preview the versions locally you can use <code>mike serve</code> instead of <code>mkdocs serve</code>.</p> <p>Warning</p> <p>Be sure to have fetched the latest changes for the <code>gh-pages</code> branch first. This is especially important if you are using <code>mike</code> locally to make manual changes to the published site.</p>"},{"location":"getting-started/configure/","title":"Configure","text":"<p><code>treefmt</code>'s behaviour can be influenced in one of three ways:</p> <ol> <li>Process flags and arguments</li> <li>Environment variables</li> <li>A TOML based config file</li> </ol> <p>There is an order of precedence between these mechanisms as listed above, with process flags having the highest precedence and values in the configuration file having the lowest.</p> <p>Note</p> <p>Some options can only be configured as process flags, others may support process flags and environment variables, and others still may support all three mechanisms.</p>"},{"location":"getting-started/configure/#config-file","title":"Config File","text":"<p>The <code>treefmt</code> configuration file is a mixture of global options and formatter sections.</p> <p>It should be named <code>treefmt.toml</code> or <code>.treefmt.toml</code>, and typically resides at the root of a repository.</p> <p>When executing <code>treefmt</code> within a subdirectory, <code>treefmt</code> will search upwards in the directory structure, looking for <code>treefmt.toml</code> or <code>.treefmt.toml</code>. You can change this behaviour using the config-file options</p> <p>Tip</p> <p>When starting a new project you can generate an initial config file using <code>treefmt --init</code></p> treefmt.toml<pre><code># The formatter multiplexer - https://github.com/numtide/treefmt\n\n# Do not exit with error if a configured formatter is missing\n# Env $TREEFMT_ALLOW_MISSING_FORMATTER\n# allow-missing-formatter = true\n\n# The file into which a cpu profile will be written\n# Env $TREEFMT_CPU_PROFILE\n# cpu-profile = ./cpu.pprof\n\n# Exclude files or directories matching the specified globs\n# Env $TREEFMT_EXCLUDES\n# excludes = [\"*.md\", \"*.gif\"]\n\n# Exit with error if any changes were made during execution\n# Useful for CI\n# Env $TREEFMT_FAIL_ON_CHANGE\n# fail-on-change = true\n\n# A list of formatters to apply\n# Defaults to all configured formatters\n# Env $TREEFMT_FORMATTERS\n# formatters = [\"gofmt\", \"prettier\"]\n\n# Log paths that did not match any formatters at the specified log level\n# Possible values are &lt;debug|info|warn|error|fatal&gt;\n# Env $TREEFMT_ON_UNMATCHED\n# on-unmatched = \"info\"\n\n# The root directory from which treefmt will start walking the filesystem\n# Defaults to the root of the current git worktree.\n# If not in a git repo, defaults to the directory containing the config file.\n# Env $TREEFMT_TREE_ROOT\n# tree-root = \"/tmp/foo\"\n\n# File to search for to find the tree root (if tree-root is not set)\n# Env $TREEFMT_TREE_ROOT_FILE\n# tree-root-file = \".git/config\"\n\n# Command to run to find the tree root. It is parsed using shlex, to allow quoting arguments that contain whitespace.\n# If you wish to pass arguments containing quotes, you should use nested quotes e.g. \"'\" or '\"'\n# Env $TREEFMT_TREE_ROOT_CMD\n# tree-root-cmd = \"git rev-parse --show-toplevel\"\n\n# Set the verbosity of logs\n# 0 = warn, 1 = info, 2 = debug\n# Env $TREEFMT_VERBOSE\n# verbose = 2\n\n# The method used to traverse the files within the tree root\n# Currently, we support 'auto', 'git', 'jujutsu', or 'filesystem'\n# Env $TREEFMT_WALK\n# walk = \"filesystem\"\n\n[formatter.mylanguage]\n# Command to execute\ncommand = \"command-to-run\"\n# Command-line arguments for the command\noptions = []\n# Glob pattern of files to include\nincludes = [ \"*.&lt;language-extension&gt;\" ]\n# Glob patterns of files to exclude\nexcludes = []\n# Controls the order of application when multiple formatters match the same file\n# Lower the number, the higher the precedence\n# Default is 0\npriority = 0\n</code></pre>"},{"location":"getting-started/configure/#global-options","title":"Global Options","text":""},{"location":"getting-started/configure/#allow-missing-formatter","title":"<code>allow-missing-formatter</code>","text":"<p>Do not exit with error if a configured formatter is missing.</p> FlagEnvConfig <pre><code>treefmt --allow-missing-formatter true\n</code></pre> <pre><code>TREEFMT_ALLOW_MISSING_FORMATTER=true treefmt\n</code></pre> <pre><code>allow-missing-formatter = true\n</code></pre>"},{"location":"getting-started/configure/#ci","title":"<code>ci</code>","text":"<p>Runs treefmt in a CI mode, enabling no-cache, fail-on-change and adjusting some other settings best suited to a continuous integration environment.</p> FlagEnv <pre><code>treefmt --ci\n</code></pre> <pre><code>TREEFMT_CI=true treefmt\n</code></pre>"},{"location":"getting-started/configure/#clear-cache","title":"<code>clear-cache</code>","text":"<p>Reset the evaluation cache. Use in case the cache is not precise enough.</p> FlagEnv <pre><code>treefmt -c\ntreefmt --clear-cache\n</code></pre> <pre><code>TREEFMT_CLEAR_CACHE=true treefmt\n</code></pre>"},{"location":"getting-started/configure/#config-file_1","title":"<code>config-file</code>","text":"FlagEnv <pre><code>treefmt --config-file /tmp/treefmt.toml\n</code></pre> <pre><code>TREEFMT_CONFIG=/tmp/treefmt.toml treefmt\n</code></pre>"},{"location":"getting-started/configure/#cpu-profile","title":"<code>cpu-profile</code>","text":"<p>The file into which a pprof cpu profile will be written.</p> FlagEnvConfig <pre><code>treefmt --cpu-profile ./cpu.pprof\n</code></pre> <pre><code>TREEFMT_CPU_PROFILE=./cpu.pprof treefmt\n</code></pre> <pre><code>cpu-profile = \"./cpu.pprof\"\n</code></pre>"},{"location":"getting-started/configure/#excludes","title":"<code>excludes</code>","text":"<p>An optional list of glob patterns used to exclude files from all formatters.</p> FlagEnvConfig <pre><code>treefmt --excludes *.toml,*.php,README\n</code></pre> <pre><code>TREEFMT_EXCLUDES=\"*.toml,*.php,README\" treefmt\n</code></pre> <pre><code>excludes = [\"*.toml\", \"*.php\", \"README\"]\n</code></pre>"},{"location":"getting-started/configure/#fail-on-change","title":"<code>fail-on-change</code>","text":"<p>Exit with error if any changes were made during execution.</p> FlagEnvConfig <pre><code>treefmt --fail-on-change true\n</code></pre> <pre><code>TREEFMT_FAIL_ON_CHANGE=true treefmt\n</code></pre> <pre><code>fail-on-change = true\n</code></pre>"},{"location":"getting-started/configure/#formatters","title":"<code>formatters</code>","text":"<p>A list of formatters to apply. Defaults to all configured formatters.</p> FlagEnvConfig <pre><code>treefmt -f go,toml,haskell\ntreefmt --formatters go,toml,haskell\n</code></pre> <pre><code>TREEFMT_FORMATTERS=go,toml,haskell treefmt\n</code></pre> <pre><code>formatters = [\"go\", \"toml\", \"haskell\"]\n\n[formatter.go]\n...\n\n[formatter.toml]\n...\n\n[formatter.haskell]\n...\n\n[formatter.ruby]\n...\n\n[formatter.shellcheck]\n...\n</code></pre>"},{"location":"getting-started/configure/#no-cache","title":"<code>no-cache</code>","text":"<p>Ignore the evaluation cache entirely. Useful for CI.</p> FlagEnv <pre><code>treefmt --no-cache\n</code></pre> <pre><code>TREEFMT_NO_CACHE=true treefmt\n</code></pre>"},{"location":"getting-started/configure/#on-unmatched","title":"<code>on-unmatched</code>","text":"<p>Log paths that did not match any formatters at the specified log level. Possible values are <code>&lt;debug|info|warn|error|fatal&gt;</code>.</p> <p>Warning</p> <p>If you select <code>fatal</code>, the process will exit immediately with a non-zero exit.</p> FlagEnvConfig <pre><code>treefmt -u debug\ntreefmt --on-unmatched debug\n</code></pre> <pre><code>TREEFMT_ON_UNMACTHED=info treefmt\n</code></pre> <pre><code>on-unmatched = \"debug\"\n</code></pre>"},{"location":"getting-started/configure/#quiet","title":"<code>quiet</code>","text":"<p>Suppress all output except for errors.</p> FlagEnv <pre><code>treefmt --quiet\n</code></pre> <pre><code>TREEFMT_QUIET=true treefmt\n</code></pre>"},{"location":"getting-started/configure/#stdin","title":"<code>stdin</code>","text":"<p>Format the context passed in via stdin.</p> <p>Note</p> <p>You must provide a single path argument, the value of which is used to match against the configured formatters.</p> Flag <pre><code>cat ../test.go | treefmt --stdin foo.go\n</code></pre>"},{"location":"getting-started/configure/#tree-root","title":"<code>tree-root</code>","text":"<p>The root directory from which treefmt will start walking the filesystem. Defaults to the directory containing the config file.</p> FlagEnvConfig <pre><code>treefmt --tree-root /tmp/foo\n</code></pre> <pre><code>TREEFMT_TREE_ROOT=/tmp/foo treefmt\n</code></pre> <pre><code>tree-root = \"/tmp/foo\"\n</code></pre>"},{"location":"getting-started/configure/#tree-root-cmd","title":"<code>tree-root-cmd</code>","text":"<p>Command to run to find the tree root. It is parsed using shlex, to allow quoting arguments that contain whitespace. If you wish to pass arguments containing quotes, you should use nested quotes e.g. <code>\"'\"</code> or <code>'\"'</code>.</p> <p>Note</p> <p>If walk is set to <code>git</code> and no tree root option has been defined, <code>tree-root-cmd</code> will be defaulted to <code>git rev-parse --show-toplevel</code>.</p> <p>If walk is set to <code>jujutsu</code> and no tree root option has been defined, <code>tree-root-cmd</code> will be defaulted to <code>jj workspace root</code>.</p> <p>if walk is set to <code>auto</code> (the default), <code>treefmt</code> will check if the working directory is inside a git worktree. If it is, <code>tree-root-cmd</code> will be defaulted as described above for <code>git</code>. If the working directory is inside a jujutsu worktree the <code>tree-root-cmd</code> will be defaulted as described above for <code>jujutsu</code>.</p> FlagEnvConfig <pre><code>treefmt --tree-root-cmd \"git rev-parse --show-toplevel\"\n</code></pre> <pre><code>TREEFMT_TREE_ROOT_CMD=\"git rev-parse --show-toplevel\" treefmt\n</code></pre> <pre><code>tree-root-cmd = \"git rev-parse --show-toplevel\"\n</code></pre>"},{"location":"getting-started/configure/#tree-root-file","title":"<code>tree-root-file</code>","text":"<p>File to search for to find the tree root (if <code>tree-root</code> is not set)</p> FlagEnvConfig <pre><code>treefmt --tree-root-file .git/config\n</code></pre> <pre><code>TREEFMT_TREE_ROOT_FILE=.git/config treefmt\n</code></pre> <pre><code>tree-root-file = \".git/config\"\n</code></pre>"},{"location":"getting-started/configure/#verbose","title":"<code>verbose</code>","text":"<p>Set the verbosity level of logs:</p> <ul> <li><code>0</code> =&gt; <code>warn</code></li> <li><code>1</code> =&gt; <code>info</code></li> <li><code>2</code> =&gt; <code>debug</code></li> </ul> FlagEnvConfig <p>The number of <code>v</code>'s passed matches the level set.</p> <pre><code>treefmt -vv\n</code></pre> <pre><code>TREEFMT_VERBOSE=1 treefmt\n</code></pre> <pre><code>verbose = 2\n</code></pre>"},{"location":"getting-started/configure/#walk","title":"<code>walk</code>","text":"<p>The method used to traverse the files within the tree root. Currently, we support 'auto', 'git', 'jujutsu' or 'filesystem'</p> FlagEnvConfig <pre><code>treefmt --walk filesystem\n</code></pre> <pre><code>TREEFMT_WALK=filesystem treefmt\n</code></pre> <pre><code>walk = \"filesystem\"\n</code></pre>"},{"location":"getting-started/configure/#working-dir","title":"<code>working-dir</code>","text":"<p>Run as if <code>treefmt</code> was started in the specified working directory instead of the current working directory.</p> FlagEnv <pre><code>treefmt -C /tmp/foo\ntreefmt --working-dir /tmp/foo\n</code></pre> <pre><code>TREEFMT_WORKING_DIR=/tmp/foo treefmt\n</code></pre>"},{"location":"getting-started/configure/#formatter-options","title":"Formatter Options","text":"<p>Formatters are configured using a table entry in <code>treefmt.toml</code> of the form <code>[formatter.&lt;name&gt;]</code>:</p> <pre><code>[formatter.alejandra]\ncommand = \"alejandra\"\nincludes = [\"*.nix\"]\nexcludes = [\"examples/nix/sources.nix\"]\npriority = 1\n\n[formatter.deadnix]\ncommand = \"deadnix\"\noptions = [\"-e\"]\nincludes = [\"*.nix\"]\npriority = 2\n</code></pre>"},{"location":"getting-started/configure/#command","title":"<code>command</code>","text":"<p>The command to invoke when applying the formatter.</p>"},{"location":"getting-started/configure/#options","title":"<code>options</code>","text":"<p>An optional list of args to be passed to <code>command</code>.</p>"},{"location":"getting-started/configure/#includes","title":"<code>includes</code>","text":"<p>A list of glob patterns used to determine whether the formatter should be applied against a given path.</p>"},{"location":"getting-started/configure/#excludes_1","title":"<code>excludes</code>","text":"<p>An optional list of glob patterns used to exclude certain files from this formatter.</p>"},{"location":"getting-started/configure/#priority","title":"<code>priority</code>","text":"<p>Influences the order of execution. Greater precedence is given to lower numbers, with the default being <code>0</code>.</p>"},{"location":"getting-started/configure/#same-file-multiple-formatters","title":"Same file, multiple formatters?","text":"<p>For each file, <code>treefmt</code> determines a list of formatters based on the configured <code>includes</code> / <code>excludes</code> rules. This list is then sorted, first by priority (lower the value, higher the precedence) and secondly by formatter name (lexicographically).</p> <p>The resultant sequence of formatters is used to create a batch key, and similarly matched files get added to that batch until it is full, at which point the files are passed to each formatter in turn.</p> <p>This means that <code>treefmt</code> guarantees only one formatter will be operating on a given file at any point in time. Another consequence is that formatting is deterministic for a given file and a given <code>treefmt</code> configuration.</p> <p>By setting the priority fields appropriately, you can control the order in which those formatters are applied for any files they both happen to match on.</p>"},{"location":"getting-started/configure/#glob-patterns-format","title":"Glob patterns format","text":"<p>This is a variant of the Unix glob pattern. It supports all the usual selectors such as <code>*</code> and <code>?</code>.</p>"},{"location":"getting-started/configure/#examples","title":"Examples","text":"<ul> <li><code>*.go</code> - match all files in the project that end with a \".go\" file extension.</li> <li><code>vendor/*</code> - match all files under the vendor folder, recursively.</li> </ul>"},{"location":"getting-started/configure/#supported-formatters","title":"Supported Formatters","text":"<p>Any formatter that follows the spec is supported out of the box.</p> <p>Already 60+ formatters are supported.</p> <p>To find examples, take a look at https://github.com/numtide/treefmt-nix/tree/main/examples.</p> <p>If you are a Nix user, you might also like https://github.com/numtide/treefmt-nix, which uses Nix to pull in the right formatter package and seamlessly integrates both together.</p>"},{"location":"getting-started/install/","title":"Install","text":"<p>There are two ways to install <code>treefmt</code>:</p> <ol> <li>Download the latest binary</li> <li>Compile and build from source.</li> </ol>"},{"location":"getting-started/install/#download-a-binary-file","title":"Download a binary file","text":"<p>You can download the latest <code>treefmt</code> binaries here.</p>"},{"location":"getting-started/install/#build-from-source","title":"Build from source","text":"<p>There are several ways to build <code>treefmt</code> from source. Your choice will depend on whether you're a nix user or not.</p>"},{"location":"getting-started/install/#non-nix-user","title":"Non-Nix User","text":"<p>To try the project without building it, run the following from the project root folder:</p> <pre><code>$ go run main.go --help\n</code></pre> <p>This command will output the manual. You can run the tool in this manner with any other flag or option to format your project.</p> <p>To build a binary, you need to have <code>go 1.22</code> installed. You can find instructions on how to install a <code>go</code> compiler here.</p> <p>To build the project, run the following:</p> <pre><code>$ go build\n</code></pre> <p>After the build command exits successfully, you will find the <code>treefmt</code> binary in the project root folder.</p>"},{"location":"getting-started/install/#nix-user","title":"Nix User","text":"<p>If you're using both <code>treefmt</code> and <code>nix</code>, you can make use of <code>treefmt-nix</code>, a wrapper that makes installing and configuring <code>treefmt</code> with <code>nix</code> easier.</p> <p>Non-flake user</p> <p>Here you also have two options: you can install <code>treefmt</code> with plain <code>nix-build</code>, or with <code>nix-shell</code>.</p> <p>To build the package with <code>nix-build</code>, run the following:</p> <pre><code>$ nix-build -A packages.x86_64-linux.treefmt\n</code></pre> <p>note: substitute <code>x86_64-linux</code> for the target system you with to build for</p> <p>Nix-flake user</p> <p>If you want to use this repository with flakes, first ensure you have flakes enabled. You can then execute the following command in the project root folder:</p> <pre><code>$ nix run . -- --help\n</code></pre> <p>To build the project, run the following command in the project root folder:</p> <pre><code>$ nix build\n</code></pre> <p>The <code>treefmt</code> binary will be available in the <code>result</code> folder.</p>"},{"location":"getting-started/usage/","title":"Usage","text":"<p><code>treefmt</code> has the following specification:</p> <pre><code>The formatter multiplexer\n\nUsage:\n  treefmt &lt;paths...&gt; [flags]\n\nFlags:\n      --allow-missing-formatter   Do not exit with error if a configured formatter is missing. (env $TREEFMT_ALLOW_MISSING_FORMATTER)\n      --ci                        Runs treefmt in a CI mode, enabling --no-cache, --fail-on-change and adjusting some other settings best suited to a CI use case. (env $TREEFMT_CI)\n  -c, --clear-cache               Reset the evaluation cache. Use in case the cache is not precise enough. (env $TREEFMT_CLEAR_CACHE)\n      --completion string         [bash|zsh|fish] Generate shell completion scripts for the specified shell.\n      --config-file string        Load the config file from the given path (defaults to searching upwards for treefmt.toml or .treefmt.toml).\n      --cpu-profile string        The file into which a cpu profile will be written. (env $TREEFMT_CPU_PROFILE)\n      --excludes strings          Exclude files or directories matching the specified globs. (env $TREEFMT_EXCLUDES)\n      --fail-on-change            Exit with error if any changes were made. Useful for CI. (env $TREEFMT_FAIL_ON_CHANGE)\n  -f, --formatters strings        Specify formatters to apply. Defaults to all configured formatters. (env $TREEFMT_FORMATTERS)\n  -h, --help                      help for treefmt\n  -i, --init                      Create a treefmt.toml file in the current directory.\n      --no-cache                  Ignore the evaluation cache entirely. Useful for CI. (env $TREEFMT_NO_CACHE)\n  -u, --on-unmatched string       Log paths that did not match any formatters at the specified log level. Possible values are &lt;debug|info|warn|error|fatal&gt;. (env $TREEFMT_ON_UNMATCHED) (default \"info\")\n  -q, --quiet                     Disable all logs except errors. (env $TREEFMT_QUIET)\n      --stdin                     Format the context passed in via stdin.\n      --tree-root string          The root directory from which treefmt will start walking the filesystem. Defaults to the root of the current git or jujutsu worktree. If not in a git or jujutsu repo, defaults to the directory containing the config file. (env $TREEFMT_TREE_ROOT)\n      --tree-root-cmd string      Command to run to find the tree root. It is parsed using shlex, to allow quoting arguments that contain whitespace. If you wish to pass arguments containing quotes, you should use nested quotes e.g. \"'\" or '\"'. (env $TREEFMT_TREE_ROOT_CMD)\n      --tree-root-file string     File to search for to find the tree root. (env $TREEFMT_TREE_ROOT_FILE)\n  -v, --verbose count             Set the verbosity of logs e.g. -vv. (env $TREEFMT_VERBOSE)\n      --version                   version for treefmt\n      --walk string               The method used to traverse the files within the tree root. Currently supports &lt;auto|git|jujutsu|filesystem&gt;. (env $TREEFMT_WALK) (default \"auto\")\n  -C, --working-dir string        Run as if treefmt was started in the specified working directory instead of the current working directory. (env $TREEFMT_WORKING_DIR) (default \".\")\n</code></pre> <p>Typically, you will execute <code>treefmt</code> from the root of your repository with no arguments:</p> <pre><code>\u276f treefmt\ntraversed 106 files\nemitted 9 files for processing\nformatted 6 files (2 changed) in 184ms\n</code></pre>"},{"location":"getting-started/usage/#clear-cache","title":"Clear Cache","text":"<p>To force re-evaluation of the entire tree, you run <code>treefmt</code> with the <code>-c</code> or <code>--clear-cache</code> flag:</p> <pre><code>\u276f treefmt -c\ntraversed 106 files\nemitted 106 files for processing\nformatted 56 files (0 changed) in 363ms\n\n\u276f treefmt --clear-cache\ntraversed 106 files\nemitted 106 files for processing\nformatted 56 files (0 changed) in 351ms\n</code></pre>"},{"location":"getting-started/usage/#change-working-directory","title":"Change working directory","text":"<p>Similar to git, <code>treefmt</code> has an option to change working directory before executing:</p> <pre><code>\u276f treefmt -C test/examples --allow-missing-formatter\ntraversed 106 files\nemitted 56 files for processing\nformatted 46 files (1 changed) in 406ms\n</code></pre>"},{"location":"getting-started/usage/#format-files-directories","title":"Format files &amp; directories","text":"<p>To format one or more specific files, you can pass them as arguments.</p> <pre><code>&gt; treefmt default.nix walk/walk.go nix/devshells/renovate.nix\ntraversed 3 files\nemitted 3 files for processing\nformatted 3 files (0 changed) in 144ms\n</code></pre> <p>You can also pass directories:</p> <pre><code>&gt; treefmt nix walk/cache\ntraversed 9 files\nemitted 8 files for processing\nformatted 7 files (0 changed) in 217ms\n</code></pre> <p>Note</p> <p>When passing directories as arguments, <code>treefmt</code> will traverse them using the configured walk strategy.</p>"},{"location":"getting-started/usage/#format-stdin","title":"Format stdin","text":"<p>Using the stdin option, <code>treefmt</code> can format content passed via <code>stdin</code>, forwarding its output to <code>stdout</code>:</p> <pre><code>\u276f cat default.nix | treefmt --stdin foo.nix\n# This file provides backward compatibility to nix &lt; 2.4 clients\n{system ? builtins.currentSystem}: let\n  lock = builtins.fromJSON (builtins.readFile ./flake.lock);\n\n  inherit\n    (lock.nodes.flake-compat.locked)\n    owner\n    repo\n    rev\n    narHash\n    ;\n\n  flake-compat = fetchTarball {\n    url = \"https://github.com/${owner}/${repo}/archive/${rev}.tar.gz\";\n    sha256 = narHash;\n  };\n\n  flake = import flake-compat {\n    inherit system;\n    src = ./.;\n  };\nin\n  flake.defaultNix\n</code></pre>"},{"location":"getting-started/usage/#shell-completion","title":"Shell Completion","text":"<p>To generate completions for your preferred shell:</p> <pre><code>\u276f treefmt --completion bash\n\u276f treefmt --completion fish\n\u276f treefmt --completion zsh\n</code></pre>"},{"location":"getting-started/usage/#ci-integration","title":"CI integration","text":"<p>We recommend using the CI option in continuous integration environments.</p> <p>You can configure a <code>treefmt</code> job in a GitHub pipeline for Ubuntu with <code>nix-shell</code> like this:</p> <pre><code>name: treefmt\non:\n    pull_request:\n    push:\n        branches: main\njobs:\n    formatter:\n        runs-on: ubuntu-latest\n        steps:\n            - uses: actions/checkout@v4\n            - uses: cachix/install-nix-action@v26\n              with:\n                  nix_path: nixpkgs=channel:nixos-unstable\n            - uses: cachix/cachix-action@v14\n              with:\n                  name: nix-community\n                  authToken: \"${{ secrets.CACHIX_AUTH_TOKEN }}\"\n            - name: treefmt\n              run: nix-shell -p treefmt --run \"treefmt --ci\"\n</code></pre>"},{"location":"guides/unmatched-formatters/","title":"Handling Unmatched Files","text":"<p>By default, treefmt lists all files that aren't matched by any formatter:</p> <pre><code>$ treefmt\nWARN no formatter for path: .gitignore\nWARN no formatter for path: LICENSE\nWARN no formatter for path: README.md\nWARN no formatter for path: go.mod\nWARN no formatter for path: go.sum\nWARN no formatter for path: build/build.go\n# ...\n</code></pre> <p>This helps you decide whether to add formatters for specific files or ignore them entirely.</p>"},{"location":"guides/unmatched-formatters/#customizing-notifications","title":"Customizing Notifications","text":""},{"location":"guides/unmatched-formatters/#reducing-log-verbosity","title":"Reducing Log Verbosity","text":"<p>If you find the unmatched file warnings too noisy, you can lower the logging level in your config:</p> <p><code>treefmt.toml</code>:</p> <pre><code>on-unmatched = \"debug\"\n</code></pre> <p>To later find out what files are unmatched, you can override this setting via the command line:</p> <pre><code>$ treefmt --on-unmatched warn\n</code></pre>"},{"location":"guides/unmatched-formatters/#enforcing-strict-matching","title":"Enforcing Strict Matching","text":"<p>Another stricter policy approach is to fail the run if any unmatched files are found. This can be paired with an <code>excludes</code> list to ignore specific files:</p> <p><code>treefmt.toml</code>:</p> <pre><code># Fail if any unmatched files are found\non-unmatched = \"fatal\"\n\n# List files to explicitly ignore\nexcludes = [\n  \"LICENCE\",\n  \"go.sum\",\n]\n</code></pre>"},{"location":"reference/formatter-spec/","title":"Formatter Specification","text":"<p>To keep the design of <code>treefmt</code> simple, we only support formatters that adhere to a certain standard. This document outlines that standard.</p> <p>In this design, we rely on <code>treefmt</code> to do the tree traversal, and only invoke the formatter on the selected files.</p> <p>Note</p> <p>If the formatter you would like to use doesn't comply with the rules, it's often possible to create a wrapper script that transforms the usage to match the specification.</p>"},{"location":"reference/formatter-spec/#rules","title":"Rules","text":"<p>In order for the formatter to comply with this spec, it MUST satisfy the following:</p>"},{"location":"reference/formatter-spec/#1-files-passed-as-arguments","title":"1. Files passed as arguments","text":"<p>The formatter's CLI must be of the form:</p> <pre><code>&lt;command&gt; [options] [...&lt;files&gt;]\n</code></pre> <p>Where:</p> <ul> <li><code>&lt;command&gt;</code> is the name of the formatter executable.</li> <li><code>[options]</code> is any number of flags and options that the formatter accepts.</li> <li><code>[...&lt;files&gt;]</code> is one or more files given to the formatter for processing.</li> </ul> <p>Example:</p> <pre><code>$ rustfmt --edition 2018 src/main.rs src/lib.rs\n</code></pre> <p>Note</p> <p>It MUST process the specified files. For example, it MUST NOT ignore files because they are not tracked by a VCS.</p> <p>It SHOULD processes only the specified files. Files that are not passed SHOULD never be formatted.</p>"},{"location":"reference/formatter-spec/#2-write-to-changed-files","title":"2. Write to changed files","text":"<p>Whenever there is a change to the code formatting, the formatter MUST write those changes back to the original location.</p> <p>If there are no changes to the original file, the formatter MUST NOT write to the original location.</p>"},{"location":"reference/formatter-spec/#3-exit-nonzero-on-error","title":"3. Exit nonzero on error","text":"<p>When something goes wrong when formatting (for example, the source code is syntactically invalid), the formatter MUST exit nonzero.</p> <p>The formatter SHOULD print useful information about what went wrong to stderr.</p>"},{"location":"reference/formatter-spec/#4-idempotent","title":"4. Idempotent","text":"<p>The formatter SHOULD be idempotent. Meaning that it produces stable outputs.</p>"},{"location":"reference/formatter-spec/#5-reliable","title":"5. Reliable","text":"<p>We expect the formatter to be reliable and not break the semantics of the formatted files.</p>"}]}